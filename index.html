<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Computer Networking: A Top-Down Approach (7e) Notes</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h1 id="computer-networking-a-top-down-approach-7e-notes">Computer Networking: A Top-Down Approach (7e) Notes</h1>
<h2 id="chapter-1---computer-networks-and-the-internet">Chapter 1 - Computer Networks and the Internet</h2>
<h3 id="11">1.1</h3>
<ul>
<li><strong>host</strong> = Internet end system = device connected to internet</li>
<li>hosts connected by <strong>communication links</strong> (actual media of transfer) and <strong>packet switches</strong></li>
<li><strong>packet</strong> = package of info consisting of segmented data w/ header bytes to be sent over network</li>
<li>two types of packet switches, <strong>router</strong> (in network core) and <strong>link-layer switch</strong> (in access network)</li>
<li><strong>route/path</strong> = sequence of communication links and packet switches traversed by a packet</li>
<li>end systems access Internet through big networks called <strong>ISPs</strong></li>
<li><strong>protocols</strong> control sending/receiving of info on internet (define format, order of messages, actions taken on send/receipt)</li>
<li><strong>Transmission Control Protocol (TCP)</strong> and <strong>Internet Protocol (IP)</strong> (which specifies format of packets sent on internet) are two of the most important, and collectively called <strong>TCP/IP</strong></li>
<li><strong>Internet standards</strong> are developed by the IETF and standards documents are called <strong>request for comments (RFCs)</strong></li>
</ul>
<h3 id="12">1.2</h3>
<ul>
<li>hosts split into <strong>clients</strong> and <strong>servers</strong></li>
<li>two most prevalent types of broadband residential access are <strong>digital subscriber line (DSL)</strong> which uses telephone lines and cable which uses optic fiber and coaxial cable</li>
<li><strong>fiber to the home (FTTH)</strong> new tech that uses optical fibers all the way to residence and allows much faster speeds</li>
<li>Physical media for transmission: twisted-pair copper wires, coaxial cable, fiber optics, terrestrial and sattelite radio channels</li>
</ul>
<h3 id="13">1.3</h3>
<ul>
<li>most packet switches use <strong>store-and-forward</strong> transmission at inputs to links (must receive entire packet before sending)</li>
<li>packet switch has <strong>output buffer/queue</strong> for each link that stores packets the router is about to send</li>
<li>packets suffer store-and-forward delays as well as output buffer delays, which can lead to <strong>packet loss</strong> if buffer fills</li>
<li>each router has a <strong>forwarding table</strong> that maps packet destination addresses to the router's outbound links</li>
<li>the Internet has special <strong>routing protocols</strong> used to automatically set forwarding tables</li>
<li>another approach to moving data in network called <strong>circuit switching</strong> reserves the resources for communication between end systems for the duration of transmission</li>
<li>in circuit switching, when hosts want to communicate, the network establishes a dedicated <strong>end-to-end connection</strong> between them</li>
<li>a circuit in a link is implemented with either <strong>frequency-division multiplexing (FDM)</strong> which dedicates frequency band to each connection or <strong>time-division multiplexing (TDM)</strong> which dedicates time-slots</li>
<li>while p-switching has variable e2e delays, it offers better sharing of transmission capacity (no silent periods like in c-switching) and is simpler, more efficient, and less costly to implement than c-switching</li>
<li>there's a hierarchy of ISPs that have a <strong>customer</strong> and <strong>provider</strong> relationship, where <strong>access ISPs</strong> connect to larger <strong>regional ISPs</strong> which then connect to massive <strong>tier-1 ISPs'</strong></li>
<li>additionally in the structure, there are <strong>points of presence (PoPs)</strong> which are groups of routers at connection b/w ISPs, <strong>multi-homing</strong> which is connecting to multiple provider ISPs, <strong>peering</strong> where lower level ISPs connect directly without settlement, and <strong>Internet Exchange Points (IXPs)</strong> which are 3rd party meeting points for peering, and lastly <strong>content provider networks</strong> like Google</li>
</ul>
<h3 id="14">1.4</h3>
<ul>
<li>packet switch delays at each node are <strong>nodal processing delay</strong> (examining header and where to direct packet), <strong>queuing delay</strong> (time in output buffer), <strong>transmission delay</strong> (time to push onto link = length of packet in bits / transmission rate), and <strong>propogation delay</strong> (actual time on link) which together sum to <strong>total nodal delay</strong></li>
<li>let <em>a</em> denote avg rate packets arrive at queue, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>a</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">La/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> = <strong>traffic intensity</strong> and should be less than or equal to one</li>
<li>e2e delay = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><msub><mi>d</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>c</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>s</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>p</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(d_{proc} + d_{trans} + d_{prop})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, where there are <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> routers between source and dest hosts</li>
<li>route tracing and delay measurement can be done with Traceroute tool</li>
<li><strong>instantatneous throughput</strong> is the rate (in bits/s) of data receipt at dest. host at any instant of time and <strong>average throughput</strong> is the total number of bits / total number of seconds</li>
<li>throughput depends on transmission rates of links being used, and can be approximated by minimum transmission rate along path</li>
</ul>
<h3 id="15">1.5</h3>
<ul>
<li>network protocols are organized into <strong>layers</strong> where each layer offers <strong>services</strong> to the layer above (<strong>service model</strong>)</li>
<li>together layers make up <strong>protocol stacks</strong>, the Internet's consisting of physical (physically move individual bits), link (moves datagram to next node in route (in packets called <strong>frames</strong>)), network (move datagrams from one host to another), transport (transports messages between application endpoints via segments w/ protocols like TCP or UDP), and application (for app to app layer messages like HTTP, FTP, SMTP) layers</li>
<li>encapsulation - each layer uses its own type of packet consisting of a header field and a payload field which typically contains a higher level packet</li>
</ul>
<h3 id="16">1.6</h3>
<ul>
<li>bad things: malware (virus/worm), DoS/DDoS, packet sniffers (like Wireshark), IP Spoofing</li>
</ul>
<h2 id="chapter-2---application-layer">Chapter 2 - Application Layer</h2>
<h3 id="21">2.1</h3>
<ul>
<li><strong>application architecture</strong> dictates how application is structured over various end systems, and typically fall under the paradigms of <strong>client-server</strong> or <strong>P2P</strong> architecture</li>
<li>p2p can be self-scaling and low-cost, but face issues such as being ISP friendly, being secure, and incentivizing users to volunteer resources</li>
<li><strong>processes</strong> (programs running on hosts) communicate w/ processes on other hosts via messages on network in pairs where one is labeled client and other labeled server processes.</li>
<li>processes send and receive messages on the network through a software interface called a <strong>socket</strong> (like a door) a.k.a. the API b/w app and network</li>
<li>services transport layer protocols could provide: reliable data transfer, throughput, timing, security</li>
<li>TCP services - connection oriented service (client &amp; server exchange info before messages flow to create a full duplex <strong>TCP connection</strong>), reliable data transfer service, congestion control</li>
<li>UDP services - lightweight, connectionless, unreliable data transfer service</li>
<li><strong>application-layer protocol</strong> defines: types of messages exchanged, syntax of message types, semantics of fields, rules for when and how a process sends and responds to messages</li>
</ul>
<h3 id="22">2.2</h3>
<ul>
<li><strong>HyperText Transfer Protocol (HTTP)</strong> is the Web's application-layer protocol, and is implemented in a client program and server program that exchange HTTP messages</li>
<li>HTTP uses TCP as its underlying transport-layer protocol, and HTTP is called a stateless protocol since HTTP servers maintain no client information</li>
<li>HTTP can be configured to use either persistent (default with pipelining of requests/responses that come in at same time) or non-persistent connections (same or individual TCP connections per HTTP request)</li>
<li><strong>round trip time (RTT)</strong> = the time it takes for a small packet to travel from client to server and back to client again</li>
<li>HTTP request message consists of <strong>request line</strong> (method, URL, HTTP version) and subsequent <strong>header lines</strong> (extra info)</li>
<li>HTTP response message consists of initial <strong>status line</strong> (status code and phrase), six <strong>header lines</strong> (extra info), and then the <strong>entity body</strong> (requested object)</li>
<li>since stateless, HTTP uses cookies which includes: cookie header line in response message, cookie header line in request message, cookie file on user's system, and back-end db at website</li>
<li>a <strong>web cache</strong> (aka <strong>proxy server</strong>) is a network entity that satisfies HTTP requests on the behalf of an origin web server, and has its own disk storage which it keeps recently requested objects in</li>
<li>web caches can bypass bottlenecks, reduce costs for local ISPs, and localize traffic (often installed by ISPs and heavily used by CDNs)</li>
<li>the <strong>conditional GET</strong> message is an HTTP request that uses the GET method and includes the If-Modified-Since: header line that is used to verify that an object in the cache is up to date</li>
</ul>
<h3 id="old-23">OLD 2.3</h3>
<ul>
<li>FTP uses two parallel TCP connections to transfer a file, a <strong>control connection</strong> (for credentials, commands to change directory or get files, etc.) and a <strong>data connection</strong> (for the file data itself)</li>
<li>since its control connection is separate, it is said that FTP sends its control info <strong>out-of-band</strong>, whereas HTTP sent its control info <strong>in-band</strong></li>
<li>FTP must continuously keep state in order to associate user's account with control connection, unlike HTTP</li>
<li>common FTP commands include: USER, PASS, LIST, RETR, STOR</li>
</ul>
<h3 id="23">2.3</h3>
<ul>
<li><strong>Simple Mail Transfer Protocol (SMTP)</strong> transfers messages from sender's mail servers to recipients' mail servers</li>
<li>some commands: HELO, MAIL, FROM, RCPT TO, DATA, CRLF.CRLF, QUIT</li>
<li>SMTP primarily <strong>push protocal</strong> where HTTP more of <strong>pull protocol</strong>, SMTP imposes 7-bit ASCII restriction</li>
<li>today typically goes like this: A's user agent on local PC -SMTP-&gt; A's always-on server -SMTP-&gt; B's always on server -MAP-&gt; B's user agent</li>
<li>the last step retrieves using a <strong>Mail Access Protocol (MAP)</strong> like POP3, IMAP, or HTTP since SMTP is only a push protocol</li>
</ul>
<h3 id="27">2.7</h3>
<ul>
<li>fun TCP and UDP client/server examples in python</li>
</ul>
<h2 id="chapter-3---transport-layer">Chapter 3 - Transport Layer</h2>
<h2 id="chapter-4---the-network-layer-data-plane">Chapter 4 - The Network Layer: Data Plane</h2>
<h3 id="41">4.1</h3>
<ul>
<li>network layer moves packets from sending host to receiving host with two main functions:
<ul>
<li><strong>forwarding</strong> - router-local action of transferring a packet from input link interface to appropriate output link interface</li>
<li><strong>routing</strong> - network-wide process that determines end-to-end paths that packets take from source to destination</li>
</ul>
</li>
<li>every network router has a <strong>forwarding table</strong> that uses one or more fields in packet's header to map to output link interface</li>
<li>traditional approach: forwarding table set by routing algo, <strong>software-defined networking (SDN)</strong> approach: separate remote controller implemented in software that compute forwarding tables and interacts w/ routers</li>
<li>possible services network layer could provide: guaranteed delivery, bounded delay, in-order packet delivery, guaranteed minimal bandwidth, security (Internet's network layer only provides best-effort service)</li>
<li>terminology: &quot;forward&quot; = &quot;switch&quot;, but &quot;routers&quot; base forwarding on header info in network layer while &quot;link-layer switches&quot; base forwarding decision on values in link-layer frame</li>
</ul>
<h3 id="42">4.2</h3>
<ul>
<li><strong>input port</strong> - physical layer function of terminating incoming physical link, link-layer functions needed to talk to link layer at other side of link, and this is where network-layer lookup function is performed to consult forwarding table</li>
<li><strong>switching fabric</strong> - connects router's input ports to output ports</li>
<li><strong>output ports</strong> - stores packets received from switching fabric and transmits on outgoing link via necessary link-layer and physical-layer functions</li>
<li><strong>routing processor</strong> - performs control-plane functions:
<ul>
<li>traditional: executes routing protocols, maintains routing tables &amp; link state info, and computes forwarding table</li>
<li>SDN: communicates w/ remote controller to get and install forwarding table</li>
</ul>
</li>
<li><strong>destination-based forwarding</strong> - input port sends to output port w/ only destination info</li>
<li><strong>generalized forwarding</strong> - other variables are considered when determining which (if any) output port to send to</li>
<li><strong>longest prefix matching rule</strong> - router matches packet's dest. address w/ longest prefix in forwarding table and forwards to link associated w/ match</li>
<li><strong>switching via memory</strong> - packets are copied to and from shared memory</li>
<li><strong>switching via a bus</strong> - input port sends packet directly to output port over a shared bus, typically by prepending a switch-internal label</li>
<li><strong>switching via an interconnection network</strong> - more complicated internal networks like crossbar switches (which are non-blocking) or multi-stage switching fabrics</li>
<li>input queuing can result in <strong>head-of-the-line (HOL) blocking</strong> where queued packet must wait for transfer through fabric even w/ open output port since blocked by packet at head of the line</li>
<li>... to be continued (moving to 4.3 now)</li>
</ul>
<h3 id="43">4.3</h3>
<ul>
<li>IPv4 datagram format:
<ul>
<li>version number - IP protocol version</li>
<li>header length - determines where payload starts</li>
<li>type of service - distinguishes different types of datagrams</li>
<li>datagram length - total length of IP datagram in bytes</li>
<li>identifier, flags, fragmentation offset - fields for IP fragmentation</li>
<li>time-to-live - ensures datagrams don't circulate forever</li>
<li>protocol - transport-layer protocol to which data portion should be passed</li>
<li>header checksum - aids in detecting bit errors</li>
<li>source/dest IP addresses</li>
<li>options - used rarely to extend IP header</li>
<li>data (payload) - transport-layer segment to be delivered to dest.</li>
</ul>
</li>
<li>the <strong>maximum transmission unit (MTU)</strong> is the max amount of data a link-layer frame can carry, and is a hard limit to size of an IP datagram</li>
<li>a solution for datagrams bigger than MTUs is to break into smaller datagrams called <strong>fragments</strong> which need to be reassembled before they reach the destination's transport layer (delegated to end systems)</li>
<li>in IPv4, dest. host can examine identification fields of datagrams from same host to verify that they're fragments of same datagram, and use flag field to determine end of fragmented datagram, and offsets to put them in the right order</li>
<li>an IP address is technically associated w/ an <strong>interface</strong> (boundary b/w host/router and its links) rather than w/ host or router containing that interface</li>
<li>each IP address is 32 bits long, in <strong>dotted-decimal notation</strong> where each byte is written in decimal form and separated from other bytes by a period</li>
<li>a network interconnecting multiple host interfaces and one router interface forms a <strong>subnet</strong></li>
<li>subnets can be addressed by <strong>subnet mask</strong> like the /24 in 223.1.1.0/24 which indicates the leftmost 24 bits of the 32-bit quantity define the subnet address</li>
<li>Internet's address assignment strategy called <strong>Classless Interdomain Routing (CIDR)</strong> generalizes notion of subnet addressing where any router outside a specific organization's network only needs to consider a <strong>prefix</strong>, a certain number of leftmost significant bits of the full destination address, when sending to any address inside organization</li>
<li>before CIDR, network portions of IP address were constricted to be 1, 2, or 3 bytes in length (called <strong>classful addressing</strong>), which problematically restricted organization's networks to be of set sizes</li>
<li>ability to use single prefix to advertise multiple networks is called <strong>address aggregation</strong>, and works extremely well when addresses are allocated in blocks to ISPs</li>
<li>longes prefix matching is used when multiple matches apply, to allow for advertising of more specific and disjoint blocks of addresses</li>
<li>IP address blocks can be obtained from ISP, which get them ultimately from Internet Corporation for Assigned Names and Numbers (ICANN)</li>
<li>once organization has block of IP addresses, addresses are assigned to individual routers (by sysadmins) and hosts (by the <strong>Dynamic Host Configuration Protocol (DHCP)</strong>)</li>
<li>DHCP allows a host to obtain an IP address automatically, either a permanent or temporary one, and gives host additional info like its subnet mask, default gateway, and local DNS server address</li>
<li>hosts send <strong>DHCP discover message</strong> within a UDP packet to link-layer which passes to all nodes attached to the subnet (src: 0.0.0.0, dst: 255.255.255.255)</li>
<li>DHCP server receiving discover message responds w/ a <strong>DHCP offer message</strong> that is broadcast to all nodes on subnet, and contains transaction ID from discover message, proposed IP address for client, the network mask, and an IP address lease time</li>
<li>client chooses among one or more server offers and responds w/ a <strong>DHCP request message</strong> echoing back config params</li>
<li>server responds to request w/ a <strong>DHCP ACK message</strong> confirming, and now client can use allocated IP address</li>
<li><strong>network address translation (NAT)</strong> enabled routers allow for home networks to use reserved address space that only has meaning within local network, and then packets forwarded beyond the network use the NAT router's single IP address</li>
<li>NAT routers maintain a <strong>NAT translation table</strong> that maps port numbers to different local addresses</li>
<li>arguments against NAT include: port numbers used for hosts and not processes, interfering w/ servers on home networks (solved w/ <strong>NAT traversal</strong> tools and UPnP protocol), and also violates networking architecture</li>
<li>IPv6 designed for when IPv4 address space used up and also added other tweaks
<ul>
<li>expanded addressing capabilities: increases size to 128 bits ensuring world won't run out of addresses and introduced <strong>anycast address</strong> allowing datagram to be delivered to any of a group of hosts</li>
<li>streamlined 40-byte header: number of IPv4 fields were dropped or made optional for faster processing</li>
<li>flow labeling: allows &quot;labeling of packets belonging to particular flows for which sender requests special handling&quot;</li>
<li>fragmentation/reassembly removed, header checksum removed, and options field moved to a next header value</li>
</ul>
</li>
<li>IPv6 datagram format:
<ul>
<li>version: 6</li>
<li>traffic class: can give priority to certain datagrams over others</li>
<li>flow label: discussed above</li>
<li>payload length: number of bytes in payload</li>
<li>next header: protocol to be used in transport layer</li>
<li>hop limit: contents decremented by each router that forwards the datagram</li>
<li>source and destination addresses: in an IPv6 format</li>
<li>data: payload</li>
</ul>
</li>
<li>adopted approach to IPv4-to-IPv6 transition is <strong>tunneling</strong>, where entire IPv6 datagrams are shoved into the payload of IPv4 datagrams in a tunnel (set of intervening IPv4 routers) and then extracted by IPv6 router when received from tunnel</li>
</ul>
<h2 id="chapter-5---the-network-layer-control-plane">Chapter 5 - The Network Layer: Control Plane</h2>
<h2 id="chapter-6---the-link-layer-and-lans">Chapter 6 - The Link Layer and LANs</h2>
<h3 id="61">6.1</h3>
<ul>
<li>a <strong>node</strong> is any device that runs a link-layer protocol, e.g. hosts, routers, switches, WiFi access points, and <strong>channels</strong> are the paths between nodes</li>
<li>potential services offered by link-layer protocol: framing (encapsulating datagram within frame of certain structure), link access (like medium access control protocol, specifies rules by which frame is put onto link), reliable delivery (guarantees each datagram sent w/o error), error detection/correction (detect incorrect reading of bits)</li>
<li>link layer mostly implemented in the <strong>network adapter</strong>, aka <strong>network interface card (NIC)</strong>, which has a link-layer controller on a dedicated chip</li>
</ul>
<h3 id="62">6.2</h3>
<ul>
<li>simplest bit-level error detection is a <strong>parity bit</strong> which is set so that the number of 1s in all <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> bits either even or odd, can be extended to 2d where parity bits exist for each row and column which can identify the errored bit and even correct it (known as <strong>forward error correction (FEC)</strong>)</li>
<li><strong>Internet checksum</strong> - bytes of data treated like 16-bit ints, summed up, and then the 1's complement of this sum is stored as a checksum in header</li>
<li><strong>cyclic redundancy check (CRC) codes</strong> - sender and receiver agree on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> bit pattern known as a <strong>generator</strong> G (leftmost bit must be 1), then we append r additional bits to piece of data s.t. resulting <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">d+r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> bit pattern is divisible by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> (all operations mod 2)</li>
</ul>
<h3 id="63">6.3</h3>
<ul>
<li><strong>point-to-point link</strong> - single sender at one end and single receiver at other end (PPP, HDLC)</li>
<li><strong>broadcast link</strong> - can have multiple sending and receiving nodes all connected to the same broadcast channel, which leads to the <strong>multiple access problem</strong></li>
<li>networks have <strong>multiple access protocols</strong> by which nodes regulate transmission into shared broadcast channel to avoid <strong>collision</strong> at receivers</li>
<li><strong>channel partitioning protocols</strong> - TDM and FDM (from 1.3) and <strong>code division multiple access (CDMA)</strong> where each node given unique code to encode bits with so they can transmit simultaneously</li>
<li><strong>random access protocols</strong> - transmitting node transmits at full channel rate, but at collision waits a random amount of time before retrying
<ul>
<li>slotted ALOHA: time divided into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">L/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> second slots and node tries to transmit fully at beginning of slot, and if collision repeats at subsequent slots w/ set probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> until success
<ul>
<li>with multiple active nodes, this leads to wasted slots on collisions or when no nodes attempt to transmit into slot bc of probability</li>
</ul>
</li>
<li>Aloha: first tries transmitting immediately and then at collision retransmits w/ probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> or waits a set time w/ probability <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1-p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>
<ul>
<li>fully decentralized, but half efficiency of slotted ALOHA</li>
</ul>
</li>
<li>Carrier Sense Multiple Access (CSMA) - waits until channel is clear before transmitting (<strong>carrier sensing</strong>)</li>
<li>CSMA/CD - adds <strong>collision detection</strong> (node listens while transmitting, and if detects collision, stops transmitting)
<ul>
<li>uses <strong>binary exponential backoff</strong> algo to know how long to wait after such collision detection before retrying, as a fn of how many nodes involved in collision (coefficient of wait time chosen randomly from <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, \cdots, 2^{n} - 1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> is no. of collisions in frame)</li>
</ul>
</li>
</ul>
</li>
<li><strong>taking-turns protocols</strong> -</li>
</ul>

    </body>
    </html>